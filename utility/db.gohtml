{{- /*
  Author: Vladlena Costescu (@lbds137)
  Trigger type: `Command`
  Trigger: `db`
  Dependencies: `embed_exec`

  Operations:
    - keys <key>: List all keys in a dictionary
    - get <key>: Get a value by key
    - set <key> <value>: Set a value (value can be JSON)
    - delete <key>: Delete a key
    - add <key> <json>: Add keys from JSON to a dictionary (appends to arrays)
    - remove <key> <json>: Remove keys from a dictionary
    - dump [key|all]: Export database entries as JSON file
      - Staff: `db dump` dumps global config (userID=0), `db dump:123` dumps specific user
      - Regular users: `db dump` dumps their own data
      - `db dump <key>`: Dump specific key only
*/ -}}

{{ $globalDict := (dbGet 0 "Global").Value }}
{{ $deleteTriggerDelay := toInt ($globalDict.Get "Delete Trigger Delay") }}

{{ $commandsDict := (dbGet 0 "Commands").Value }}
{{ $embed_exec := toInt ($commandsDict.Get "embed_exec") }}

{{ $rolesDict := (dbGet 0 "Roles").Value }}
{{ $staffRoleID := toInt ($rolesDict.Get "Staff") }}

{{ $channelsDict := (dbGet 0 "Channels").Value }}
{{ $yagpdbChannelID := toInt ($channelsDict.Get "YAGPDB") }}

{{ $sDictType := "*templates.SDict" }}
{{ $stringType := "string" }}

{{ $userID := .Member.User.ID }}
{{ $operation := "" }}
{{ $key := "" }}
{{ $value := "" }}
{{ $valueType := "" }}
{{ $title := "" }}

{{ $isExec := or .ExecData.UserID .ExecData.Operation .ExecData.Key .ExecData.Value .ExecData.Title }}

{{ if $isExec }}
    {{ $userID = .ExecData.UserID }}
    {{ $operation = .ExecData.Operation }}
    {{ $key = .ExecData.Key }}
    {{ $value = .ExecData.Value }}
    {{ $valueType = printf "%T" $value }}
    {{ $title = .ExecData.Title }}
{{ else }}
    {{ if ge (len .CmdArgs) 1 }}
        {{ $operation = index .CmdArgs 0 }}
    {{ end }}

    {{ $opArray := split $operation ":" }}
    {{ if eq 2 (len $opArray) }}
        {{ $operation = index $opArray 0 }}
        {{ $userIDArg := index $opArray 1 }}

        {{ $numberCheck := or (eq "0" $userIDArg) (gt (toInt $userIDArg) 0) }}
        {{ $permissionCheck := hasRoleID $staffRoleID }}
        {{ if and $numberCheck $permissionCheck }}
            {{ $userID = toInt $userIDArg }}
        {{ end }}
    {{ end }}

    {{ if ge (len .CmdArgs) 2 }}
        {{ $key = index .CmdArgs 1 }}
    {{ end }}

    {{ if ge (len .CmdArgs) 3 }}
        {{ $value = index .CmdArgs 2 }}
        {{ $valueType = printf "%T" $value }}
    {{ end }}
{{ end }}

{{ $isKeys := eq "keys" $operation }}
{{ $isDelete := eq "delete" $operation }}
{{ $isGet := eq "get" $operation }}
{{ $isSet := eq "set" $operation }}
{{ $isAdd := eq "add" $operation }}
{{ $isRemove := eq "remove" $operation }}
{{ $isDump := eq "dump" $operation }}
{{ $operationCheck := or $isKeys $isDelete $isGet $isSet $isAdd $isRemove $isDump }}
{{ $valueCheck := or $value $isKeys $isDelete $isGet $isDump }}

{{ $nil := "(nil)" }}
{{ $resultText := "" }}
{{ $resultEmoji := "✅" }}
{{ $displayUserID := $userID }}
{{/* For dump operation, key is optional (defaults to "all") */}}
{{ if and $isDump (not $key) }}
    {{ $key = "all" }}
{{ end }}
{{ if and $operationCheck $key $valueCheck }}
    {{ $existingValue := "" }}
    {{ $existingType := "" }}

    {{ $keyArray := split $key ":" }}
    {{ $parentExistingValue := "" }}
    {{ $parentExistingType := "" }}
    {{ $lastParentExistingValue := "" }}
    {{ $firstSubkey := index $keyArray 0 }}
    {{ $lastSubkey := index $keyArray (sub (len $keyArray) 1) }}
    {{ if ge (len $keyArray) 2 }}
        {{ $parentExistingValue = (dbGet $userID $firstSubkey).Value }}
        {{ $parentExistingType = printf "%T" $parentExistingValue }}
        {{ if eq $sDictType $parentExistingType }}
            {{ $key = "" }}
            {{- range $subkey := $keyArray -}}
                {{ $key = joinStr " > " $key $subkey }}
                {{ if not $existingValue }}
                    {{ if eq $firstSubkey $subkey }}
                        {{ $existingValue = $parentExistingValue }}
                        {{ $existingType = $parentExistingType }}
                    {{ else }}
                        {{ $existingValue = "" }}
                        {{ $existingType = "" }}
                    {{ end }}
                {{ else if eq $sDictType $existingType }}
                    {{ $lastParentExistingValue = $existingValue }}
                    {{ $existingValue = $existingValue.Get $subkey }}
                    {{ $existingType = printf "%T" $existingValue }}
                {{ end }}
            {{- end -}}
        {{ end }}
    {{ else }}
        {{ $existingValue = (dbGet $userID $key).Value }}
        {{ $existingType = printf "%T" $existingValue }}
        {{ $lastParentExistingValue = $existingValue }}
    {{ end }}

    {{ $ptAction := "" }}
    {{ if $isDump }}
        {{/* Dump operation: export database entries as JSON file */}}
        {{/* Staff can dump global config (userID=0) or any user via db dump:userID */}}
        {{/* Regular users can only dump their own data */}}
        {{ $dumpUserID := .Member.User.ID }}
        {{ if hasRoleID $staffRoleID }}
            {{/* Staff defaults to global config (userID=0), but can specify other IDs */}}
            {{ if eq $userID .Member.User.ID }}
                {{ $dumpUserID = 0 }}
            {{ else }}
                {{ $dumpUserID = $userID }}
            {{ end }}
        {{ end }}
        {{ $dumpData := sdict }}
        {{ $knownKeys := cslice "Global" "Commands" "Channels" "Roles" "Admin" "Gematria" "Knowledge" "Rules" "Directory" }}
        {{ if and $key (ne $key "all") }}
            {{/* Dump specific key only */}}
            {{ $knownKeys = cslice $key }}
        {{ end }}
        {{ range $k := $knownKeys }}
            {{ $entry := dbGet $dumpUserID $k }}
            {{ if and $entry $entry.Value }}
                {{ $dumpData.Set $k $entry.Value }}
            {{ end }}
        {{ end }}
        {{ $ptAction = "dumped" }}
        {{ $displayUserID = $dumpUserID }}
        {{ $jsonData := json $dumpData true }}
        {{ $filename := joinStr "" "db_dump_" (toString $dumpUserID) "_" (currentTime.Unix) }}
        {{ sendMessage nil (complexMessage "file" $jsonData "filename" $filename) }}
        {{ $value = joinStr "" "Exported " (len $dumpData) " entries to file" }}
    {{ else if $isKeys }}
        {{ if eq $sDictType $existingType }}
            {{ $ptAction = "inspected" }}
            {{ $value = cslice }}
            {{- range $k, $v := $existingValue -}}
                {{- $value = $value.Append $k -}}
            {{- end -}}
        {{ end }}
    {{ else if or $isDelete $isGet }}
        {{ if or $existingValue (eq $sDictType $existingType) }}
            {{ $value = $existingValue }}
            {{ if $isDelete }}
                {{ $ptAction = "deleted" }}
                {{ if ge (len $keyArray) 2 }}
                    {{ $lastParentExistingValue.Del $lastSubkey }}
                    {{ dbSet $userID $firstSubkey $parentExistingValue }}
                {{ else }}
                    {{ dbDel $userID $key }}
                {{ end }}
            {{ else if $isGet }}
                {{ $ptAction = "retrieved" }}
            {{ end }}
        {{ end }}
    {{ else if or $isAdd $isRemove }}
        {{ try }}
            {{ $parsedValue := $value }}
            {{ if eq $stringType $valueType }}
                {{/* Only try parsing as JSON if it starts with { (JSON object) */}}
                {{ if and (gt (len $value) 0) (eq "{" (index $value 0 | printf "%c")) }}
                    {{ $parsedValue = jsonToSdict $value }}
                {{ end }}
            {{ end }}
            {{ if $isAdd }}
                {{ $ptAction = "added" }}
            {{ else }}
                {{ $ptAction = "removed" }}
            {{ end }}
            {{ $lastParentExistingType := printf "%T" $lastParentExistingValue }}
            {{ $existingIsSlice := eq "slice" (kindOf $existingValue) }}
            {{/* Direct array append: if target is a slice, append the value */}}
            {{ if and $existingIsSlice $isAdd }}
                {{/* Convert raw slice to cslice and append */}}
                {{ $newSlice := cslice }}
                {{ range $item := $existingValue }}
                    {{ $newSlice = $newSlice.Append $item }}
                {{ end }}
                {{ $newSlice = $newSlice.Append $parsedValue }}
                {{ $existingValue = $newSlice }}
                {{/* Update the parent with the modified slice */}}
                {{ if ge (len $keyArray) 2 }}
                    {{ $lastParentExistingValue.Set $lastSubkey $existingValue }}
                    {{ dbSet $userID $firstSubkey $parentExistingValue }}
                {{ else }}
                    {{ dbSet $userID $key $existingValue }}
                {{ end }}
                {{ $value = $parsedValue }}
            {{ else if eq $sDictType $lastParentExistingType }}
                {{/* Dict operations: add/remove keys */}}
                {{ $value = $parsedValue }}
                {{- range $k, $v := $value -}}
                    {{- if $isAdd -}}
                        {{- /* Check if both existing and new values are slices - if so, append */ -}}
                        {{- $existingAtK := $lastParentExistingValue.Get $k -}}
                        {{- if and (eq "slice" (kindOf $existingAtK)) (eq "slice" (kindOf $v)) -}}
                            {{- /* Append new items to existing slice */ -}}
                            {{- range $item := $v -}}
                                {{- $existingAtK = $existingAtK.Append $item -}}
                            {{- end -}}
                            {{- $lastParentExistingValue.Set $k $existingAtK -}}
                        {{- else -}}
                            {{- $lastParentExistingValue.Set $k $v -}}
                        {{- end -}}
                    {{- else -}}
                        {{- $value.Set $k ($lastParentExistingValue.Get $k) -}}
                        {{- $lastParentExistingValue.Del $k -}}
                    {{- end -}}
                {{- end -}}

                {{ if ge (len $keyArray) 2 }}
                    {{ dbSet $userID $firstSubkey $parentExistingValue }}
                {{ else }}
                    {{ dbSet $userID $key $existingValue }}
                {{ end }}
            {{ end }}
        {{ catch }}
            {{ $value = "" }}
        {{ end }}
    {{ else }}
        {{ try }}
            {{ if eq $stringType $valueType }}
                {{ $value = jsonToSdict $value }}
            {{ end }}
            {{ $ptAction = "set" }}
            {{ if ge (len $keyArray) 2 }}
                {{ $lastParentExistingValue.Set $lastSubkey $value }}
                {{ dbSet $userID $firstSubkey $parentExistingValue }}
            {{ else }}
                {{ dbSet $userID $key $value }}
            {{ end }}
        {{ catch }}
            {{ $value = "" }}
        {{ end }}
    {{ end }}

    {{ $valueType = printf "%T" $value }}

    {{ if and $isKeys (and (not $value) (eq $stringType $valueType)) }}
        {{ $resultEmoji = "⚠️" }}
        {{ $resultText = "No dictionary found for the given key!" }}
    {{ else if and (or $isDelete $isGet) (and (not $value) (eq $stringType $valueType)) }}
        {{ $resultEmoji = "⚠️" }}
        {{ $resultText = "No value found!" }}
    {{ else if and (or $isSet $isAdd $isRemove) (and (not $value) (eq $stringType $valueType)) }}
        {{ $resultEmoji = "⚠️" }}
        {{ $resultText = "Invalid value provided! Please double check your input and try again." }}
    {{ else }}
        {{- /* format the value for user-friendly viewing */ -}}
        {{ if ne $stringType $valueType }}
            {{ try }}
                {{ $value = json $value true }}
            {{ catch }}
                {{ $value = joinStr "" "(unable to render type " $valueType ")" }}
            {{ end }}
        {{ end }}
        {{ $resultText = joinStr "" "Value successfully " $ptAction "!" }}
        {{ deleteTrigger $deleteTriggerDelay }}
    {{ end }}
{{ else }}
    {{ $resultEmoji = "⚠️" }}
    {{ if not $operationCheck }}
        {{ $resultText = joinStr "" "Invalid operation provided: " (or $operation $nil) "" }}
    {{ else if not $key }}
        {{ $resultText = "You must provide a key!" }}
    {{ else if not $valueCheck }}
        {{ $resultText = "You must provide a value!" }}
    {{ end }}
{{ end }}

{{ $resultText = joinStr " " $resultEmoji $resultText }}

{{ $embedDescriptionLimit := sub 2048 4 }}
{{ if ge (len (toRune $value)) $embedDescriptionLimit }}
    {{ $value = joinStr "" (slice $value 0 $embedDescriptionLimit) "…" }}
{{ end }}

{{ if not (and $isExec .ExecData.Title) }}
    {{ $title = joinStr "" "Database Operation: `" $operation "`" }}
{{ end }}

{{ execCC $embed_exec $yagpdbChannelID 0 (sdict
    "ChannelID" (or .ExecData.ChannelID .Channel.ID)
    "Title" $title
    "Description" (joinStr "" "```\n" (or $value $nil) "\n```")
    "AuthorID" $displayUserID
    "Fields" (cslice
        (sdict "name" "User ID" "value" (joinStr "" "```\n" $displayUserID "```") "inline" true)
        (sdict "name" "Key" "value" (joinStr "" "```\n" (or $key $nil) "```") "inline" true)
        (sdict "name" "Result" "value" (joinStr "" "```\n" $resultText "```") "inline" false)
    )
) }}
